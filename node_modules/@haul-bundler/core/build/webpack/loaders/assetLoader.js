"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _loaderUtils = _interopRequireDefault(require("loader-utils"));

var _imageSize = require("image-size");

var _path = _interopRequireDefault(require("path"));

var _dedent = _interopRequireDefault(require("dedent"));

var _hasha = _interopRequireDefault(require("hasha"));

var _escapeStringRegexp = _interopRequireDefault(require("escape-string-regexp"));

var _Runtime = _interopRequireDefault(require("../../runtime/Runtime"));

var _AssetResolver = _interopRequireDefault(require("../resolvers/AssetResolver"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function assetLoader() {
  this.cacheable();
  const callback = this.async();
  const {
    runtime: _runtime = new _Runtime.default(),
    ...query
  } = _loaderUtils.default.getOptions(this) || {};
  const runtime = _runtime;
  const config = {
    platform: 'ios',
    root: process.cwd(),
    ...query
  };
  const pathSepPattern = new RegExp(`\\${_path.default.sep}`, 'g');
  const filePath = this.resourcePath;

  const dirname = _path.default.dirname(filePath); // Relative path to root without any ../ due to https://github.com/callstack/haul/issues/474
  // Assets from from outside of root, should still be placed inside bundle output directory.
  // Example:
  //   filePath = monorepo/node_modules/my-module/image.png
  //   dirname  = monorepo/node_modules/my-module
  //   root     = monorepo/packages/my-app/
  //   url      = ../../node_modules/my-module (original)
  // So when we calculate destination for the asset for iOS ('assets' + url + filename),
  // it will end up outside of `assets` directory, so we have to make sure it's:
  //   url      = node_modules/my-module (tweaked)


  const url = _path.default.relative(config.root, dirname).replace(new RegExp(`^[\\.\\${_path.default.sep}]+`), '');

  const type = _path.default.extname(filePath).replace(/^\./, '');

  const assets = _path.default.join('assets', config.bundle ? '' : config.platform);

  const suffix = `(@\\d+(\\.\\d+)?x)?(\\.(${config.platform}|native))?\\.${type}$`;

  const filename = _path.default.basename(filePath).replace(new RegExp(suffix), '');

  const normalizedName = url.length === 0 ? filename : `${url.replace(pathSepPattern, '_')}_${filename}`;
  const longName = `${normalizedName.toLowerCase().replace(/[^a-z0-9_]/g, '')}.${type}`;
  const result = await new Promise((resolve, reject) => this.fs.readdir(dirname, (err, res) => {
    if (err) {
      reject(err);
    } else {
      resolve(res);
    }
  }));

  const map = _AssetResolver.default.collect(result, {
    name: filename,
    type,
    platform: config.platform
  });

  const scales = Object.keys(map).map(s => Number(s.replace(/[^\d.]/g, ''))).sort();
  const pairs = await Promise.all(Object.keys(map).map(scale => {
    this.addDependency(_path.default.join(dirname, map[scale].name));
    return new Promise((resolve, reject) => this.fs.readFile(_path.default.join(dirname, map[scale].name), (err, res) => {
      runtime.logger.debug(`Asset: ${scale} for ${filePath}`);

      if (err) {
        reject(err);
      } else {
        let dest;

        if (config.bundle && config.platform === 'android') {
          const testXml = /\.(xml)$/;
          const testMP4 = /\.(mp4)$/;
          const testImages = /\.(png|jpg|gif|webp)$/;
          const testFonts = /\.(ttf|otf|ttc)$/; // found font family

          if (testXml.test(longName) && res.indexOf('font-family') !== -1) {
            dest = 'font';
          } else if (testFonts.test(longName)) {
            // font extensions
            dest = 'font';
          } else if (testMP4.test(longName)) {
            // video files extensions
            dest = 'raw';
          } else if (testImages.test(longName) || testXml.test(longName)) {
            // images extensions
            switch (scale) {
              case '@0.75x':
                dest = 'drawable-ldpi';
                break;

              case '@1x':
                dest = 'drawable-mdpi';
                break;

              case '@1.5x':
                dest = 'drawable-hdpi';
                break;

              case '@2x':
                dest = 'drawable-xhdpi';
                break;

              case '@3x':
                dest = 'drawable-xxhdpi';
                break;

              case '@4x':
                dest = 'drawable-xxxhdpi';
                break;

              default:
                throw new Error(`Unknown scale ${scale} for ${filePath}`);
            }
          } else {
            // everything else is going to RAW
            dest = 'raw';
          }

          dest = _path.default.join(dest, longName);
        } else {
          const name = `${filename}${scale === '@1x' ? '' : scale}.${type}`;
          dest = _path.default.join(assets, url, name);
        }

        runtime.logger.debug(`Asset: file ${filePath} --> destination: ${dest}`);
        resolve({
          destination: dest,
          content: res
        });
      }
    }));
  }));
  pairs.forEach(item => {
    let dest = item.destination;

    if (config.outputPath) {
      // support functions as outputPath to generate them dynamically
      dest = typeof config.outputPath === 'function' ? config.outputPath(dest) : _path.default.join(config.outputPath, dest);
    }

    this.emitFile(dest, item.content);
  });
  let publicPath = JSON.stringify(_path.default.join(assets, url).replace(pathSepPattern, '/'));

  if (config.publicPath) {
    // support functions as publicPath to generate them dynamically
    publicPath = JSON.stringify(typeof config.publicPath === 'function' ? config.publicPath(url) : _path.default.join(config.publicPath, url));
  }

  const hashes = pairs.map(item => (0, _hasha.default)(item.content, {
    algorithm: 'md5'
  }));
  let info;

  try {
    runtime.logger.debug(`Asset: path ${this.resourcePath}`);
    info = (0, _imageSize.imageSize)(this.resourcePath);

    const match = _path.default.basename(this.resourcePath).match(new RegExp(`^${(0, _escapeStringRegexp.default)(filename)}${suffix}`));

    if (match === null || match === void 0 ? void 0 : match[1]) {
      const scale = Number(match[1].replace(/[^\d.]/g, ''));

      if (typeof scale === 'number' && Number.isFinite(scale)) {
        info.width && (info.width /= scale);
        info.height && (info.height /= scale);
      }
    }
  } catch (e) {
    // Asset is not an image
    runtime.logger.error(`Asset: unable to process ${this.resourcePath}`);
  }

  callback(null, _dedent.default`
      var AssetRegistry = require('react-native/Libraries/Image/AssetRegistry');
      module.exports = AssetRegistry.registerAsset({
        __packager_asset: true,
        scales: ${JSON.stringify(scales)},
        name: ${JSON.stringify(filename)},
        type: ${JSON.stringify(type)},
        hash: ${JSON.stringify(hashes.join())},
        httpServerLocation: ${publicPath},
        ${config.bundle ? '' : `fileSystemLocation: ${JSON.stringify(dirname)},`}
        ${info ? `height: ${info.height},` : ''}
        ${info ? `width: ${info.width},` : ''}
      });
      `);
}

assetLoader.raw = true;
var _default = assetLoader;
exports.default = _default;
//# sourceMappingURL=assetLoader.js.map