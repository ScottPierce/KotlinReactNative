{"version":3,"sources":["../../../../../src/webpack/loaders/babelWorkerLoader/vendor/cache.ts"],"names":["defaultCacheDirectory","readFile","fs","writeFile","gunzip","zlib","gzip","mkdirp","mkdirpOrig","read","filename","compress","data","content","JSON","parse","toString","write","result","stringify","source","identifier","options","hash","crypto","createHash","contents","update","digest","handleCache","directory","params","cacheIdentifier","cacheDirectory","cacheCompression","file","path","join","err","fallback","os","tmpdir","name"],"mappings":"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","sourcesContent":["import fs from 'fs';\nimport os from 'os';\nimport path from 'path';\nimport zlib from 'zlib';\nimport crypto from 'crypto';\nimport mkdirpOrig from 'mkdirp';\nimport findCacheDir from 'find-cache-dir';\nimport promisify from 'pify';\n\nimport transform from './transform';\n\nlet defaultCacheDirectory: string | null = null;\n\nconst readFile = promisify(fs.readFile);\nconst writeFile = promisify(fs.writeFile);\nconst gunzip = promisify(zlib.gunzip);\nconst gzip = promisify(zlib.gzip);\nconst mkdirp = promisify(mkdirpOrig);\n\nconst read = async function(filename: string | number, compress: any) {\n  const data = await readFile(filename + (compress ? '.gz' : ''));\n  const content = compress ? await gunzip(data) : data;\n\n  return JSON.parse(content.toString());\n};\n\nconst write = async function(\n  filename: string | number,\n  compress: any,\n  result: any\n) {\n  const content = JSON.stringify(result);\n\n  const data = compress ? await gzip(content) : content;\n  return await writeFile(filename + (compress ? '.gz' : ''), data);\n};\n\nconst filename = (source: any, identifier: any, options: any) => {\n  const hash = crypto.createHash('md4');\n  const contents = JSON.stringify({ source, options, identifier });\n\n  hash.update(contents);\n\n  return hash.digest('hex') + '.json';\n};\n\ntype handleCacheParams = {\n  source: any;\n  options?: {} | undefined;\n  cacheIdentifier: any;\n  cacheDirectory: any;\n  cacheCompression: any;\n};\n\nconst handleCache = async function(\n  directory: string,\n  params: handleCacheParams\n): Promise<any> {\n  const {\n    source,\n    options = {},\n    cacheIdentifier,\n    cacheDirectory,\n    cacheCompression,\n  } = params;\n\n  const file = path.join(directory, filename(source, cacheIdentifier, options));\n\n  try {\n    // No errors mean that the file was previously cached\n    // we just need to return it\n    return await read(file, cacheCompression);\n    // eslint-disable-next-line no-empty\n  } catch (err) {}\n\n  const fallback =\n    typeof cacheDirectory !== 'string' && directory !== os.tmpdir();\n\n  try {\n    await mkdirp(directory);\n  } catch (err) {\n    if (fallback) {\n      return handleCache(os.tmpdir(), params);\n    }\n\n    throw err;\n  }\n\n  // Otherwise just transform the file\n  // return it to the user asap and write it in cache\n  const result = await transform(source, options);\n\n  try {\n    await write(file, cacheCompression, result);\n  } catch (err) {\n    if (fallback) {\n      // Fallback to tmpdir if node_modules folder not writable\n      return handleCache(os.tmpdir(), params);\n    }\n\n    throw err;\n  }\n\n  return result;\n};\n\nexport default async function(params: handleCacheParams) {\n  if(typeof params.cacheDirectory !== 'string' && defaultCacheDirectory === null) {\n    defaultCacheDirectory =\n        findCacheDir({ name: 'babel-loader' }) || os.tmpdir();\n  }\n  const directory = params.cacheDirectory || defaultCacheDirectory\n\n  return await handleCache(directory, params);\n};\n"],"file":"cache.js"}