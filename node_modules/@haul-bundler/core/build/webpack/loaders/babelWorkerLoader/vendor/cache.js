"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _fs = _interopRequireDefault(require("fs"));

var _os = _interopRequireDefault(require("os"));

var _path = _interopRequireDefault(require("path"));

var _zlib = _interopRequireDefault(require("zlib"));

var _crypto = _interopRequireDefault(require("crypto"));

var _mkdirp = _interopRequireDefault(require("mkdirp"));

var _findCacheDir = _interopRequireDefault(require("find-cache-dir"));

var _pify = _interopRequireDefault(require("pify"));

var _transform = _interopRequireDefault(require("./transform"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

let defaultCacheDirectory = null;
const readFile = (0, _pify.default)(_fs.default.readFile);
const writeFile = (0, _pify.default)(_fs.default.writeFile);
const gunzip = (0, _pify.default)(_zlib.default.gunzip);
const gzip = (0, _pify.default)(_zlib.default.gzip);
const mkdirp = (0, _pify.default)(_mkdirp.default);

const read = async function (filename, compress) {
  const data = await readFile(filename + (compress ? '.gz' : ''));
  const content = compress ? await gunzip(data) : data;
  return JSON.parse(content.toString());
};

const write = async function (filename, compress, result) {
  const content = JSON.stringify(result);
  const data = compress ? await gzip(content) : content;
  return await writeFile(filename + (compress ? '.gz' : ''), data);
};

const filename = (source, identifier, options) => {
  const hash = _crypto.default.createHash('md4');

  const contents = JSON.stringify({
    source,
    options,
    identifier
  });
  hash.update(contents);
  return hash.digest('hex') + '.json';
};

const handleCache = async function (directory, params) {
  const {
    source,
    options = {},
    cacheIdentifier,
    cacheDirectory,
    cacheCompression
  } = params;

  const file = _path.default.join(directory, filename(source, cacheIdentifier, options));

  try {
    // No errors mean that the file was previously cached
    // we just need to return it
    return await read(file, cacheCompression); // eslint-disable-next-line no-empty
  } catch (err) {}

  const fallback = typeof cacheDirectory !== 'string' && directory !== _os.default.tmpdir();

  try {
    await mkdirp(directory);
  } catch (err) {
    if (fallback) {
      return handleCache(_os.default.tmpdir(), params);
    }

    throw err;
  } // Otherwise just transform the file
  // return it to the user asap and write it in cache


  const result = await (0, _transform.default)(source, options);

  try {
    await write(file, cacheCompression, result);
  } catch (err) {
    if (fallback) {
      // Fallback to tmpdir if node_modules folder not writable
      return handleCache(_os.default.tmpdir(), params);
    }

    throw err;
  }

  return result;
};

async function _default(params) {
  if (typeof params.cacheDirectory !== 'string' && defaultCacheDirectory === null) {
    defaultCacheDirectory = (0, _findCacheDir.default)({
      name: 'babel-loader'
    }) || _os.default.tmpdir();
  }

  const directory = params.cacheDirectory || defaultCacheDirectory;
  return await handleCache(directory, params);
}

;
//# sourceMappingURL=cache.js.map