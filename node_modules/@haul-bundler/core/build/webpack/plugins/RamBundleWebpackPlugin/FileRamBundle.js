"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _path = _interopRequireDefault(require("path"));

var _webpackSources = require("webpack-sources");

var _magicNumber = _interopRequireDefault(require("metro/src/shared/output/RamBundle/magic-number"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class FileRamBundle {
  constructor(bootstrap, modules, sourceMap, bundleName, singleBundleMode) {
    this.bootstrap = bootstrap;
    this.modules = modules;
    this.sourceMap = sourceMap;
    this.bundleName = bundleName;
    this.singleBundleMode = singleBundleMode;
  }

  build({
    outputDest,
    outputFilename,
    sourceMapFilename,
    compilation
  }) {
    const jsModulesDir = this.singleBundleMode ? _path.default.join(_path.default.dirname(outputFilename), 'js-modules') : _path.default.join(_path.default.dirname(outputFilename), `${this.bundleName}-js-modules`); // UNBUNDLE file tells React Native it's a RAM bundle.

    const UNBUNDLE = Buffer.alloc(4);
    UNBUNDLE.writeUInt32LE(_magicNumber.default, 0); // Bundle file contains only bootstrap code. Modules are stored in `js-modules`
    // in the same directory as bundle file.

    compilation.assets[outputFilename] = new _webpackSources.RawSource(this.bootstrap); // Cast buffer to any to avoid mismatch of types. RawSource works not only on strings
    // but also on Buffers.

    compilation.assets[_path.default.join(jsModulesDir, 'UNBUNDLE')] = new _webpackSources.RawSource(UNBUNDLE); // Emit JS modules

    this.modules.forEach(webpackModule => {
      const intId = typeof webpackModule.id === 'string' ? webpackModule.idx : webpackModule.id;
      compilation.assets[_path.default.join(jsModulesDir, `${intId}.js`)] = new _webpackSources.RawSource(webpackModule.source);
    });

    if (this.sourceMap) {
      const indexMap = {
        version: 3,
        file: outputDest,
        sections: []
      };
      this.modules.forEach((sourceModule, index) => {
        indexMap.sections.push({
          offset: {
            line: index,
            column: 0
          },
          map: sourceModule.map
        });
      });
      compilation.assets[sourceMapFilename] = new _webpackSources.RawSource(JSON.stringify(indexMap));
    }
  }

}

exports.default = FileRamBundle;
//# sourceMappingURL=FileRamBundle.js.map