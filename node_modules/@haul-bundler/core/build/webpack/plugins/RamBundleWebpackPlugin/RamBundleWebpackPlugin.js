"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _assert = _interopRequireDefault(require("assert"));

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _util = require("util");

var _terser = _interopRequireDefault(require("terser"));

var _jestWorker = _interopRequireDefault(require("jest-worker"));

var _IndexRamBundle = _interopRequireDefault(require("./IndexRamBundle"));

var _FileRamBundle = _interopRequireDefault(require("./FileRamBundle"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const variableToString = value => {
  if (value === undefined) {
    return 'undefined';
  }

  return typeof value === 'string' ? `"${value}"` : value.toString();
};

const hasValue = value => typeof value === 'undefined' ? false : true;

class RamBundleWebpackPlugin {
  constructor({
    sourceMap,
    indexRamBundle,
    preloadBundles,
    singleBundleMode,
    minify,
    minifyOptions,
    maxWorkers,
    bundleId,
    bundleName
  }) {
    _defineProperty(this, "name", 'RamBundleWebpackPlugin');

    _defineProperty(this, "modules", []);

    _defineProperty(this, "sourceMap", false);

    _defineProperty(this, "indexRamBundle", true);

    _defineProperty(this, "preloadBundles", void 0);

    _defineProperty(this, "bundleId", 'index');

    _defineProperty(this, "bundleName", 'index');

    _defineProperty(this, "singleBundleMode", true);

    _defineProperty(this, "minify", false);

    _defineProperty(this, "minifyOptions", undefined);

    _defineProperty(this, "maxWorkers", void 0);

    this.sourceMap = Boolean(sourceMap);
    this.indexRamBundle = Boolean(indexRamBundle);
    this.preloadBundles = preloadBundles || [];
    this.singleBundleMode = hasValue(singleBundleMode) ? Boolean(singleBundleMode) : this.singleBundleMode;
    this.minify = hasValue(minify) ? Boolean(minify) : this.minify;
    this.minifyOptions = minifyOptions;
    this.maxWorkers = maxWorkers;
    this.bundleId = bundleId;
    this.bundleName = bundleName;
  }

  apply(compiler) {
    compiler.hooks.emit.tapPromise('RamBundleWebpackPlugin', async _compilation => {
      // Cast compilation from @types/webpack to custom Compilation type
      // which contains additional properties.
      const compilation = _compilation;
      const moduleMappings = {
        modules: {},
        chunks: {}
      };
      let mainId;
      let mainChunk;
      compilation.chunks.forEach(chunk => {
        if (chunk.id === 'main' || chunk.name === 'main') {
          var _ref, _chunk$entryModule;

          mainChunk = chunk;
          mainId = (_ref = (_chunk$entryModule = chunk.entryModule) === null || _chunk$entryModule === void 0 ? void 0 : _chunk$entryModule.id) !== null && _ref !== void 0 ? _ref : undefined;
        }

        chunk.getModules().forEach(moduleInChunk => {
          if (chunk.id !== null) {
            var _moduleInChunk$id;

            moduleMappings.chunks[chunk.id] = [].concat(...(moduleMappings.chunks[chunk.id] || [])).concat((_moduleInChunk$id = moduleInChunk.id) !== null && _moduleInChunk$id !== void 0 ? _moduleInChunk$id : []);
          }
        });
      }); // Omit chunks mapping if there's only a single main chunk

      if (compilation.chunks.length === 1) {
        moduleMappings.chunks = {};
      }

      if (mainId === undefined) {
        throw new Error("RamBundleWebpackPlugin: couldn't find main chunk's entry module id");
      }

      if (!mainChunk) {
        throw new Error("RamBundleWebpackPlugin: couldn't find main chunk");
      } // Render modules to it's 'final' form with injected webpack variables
      // and wrapped with ModuleTemplate.


      const minifyWorker = new _jestWorker.default(require.resolve('../../../../build/webpack/plugins/RamBundleWebpackPlugin/worker'), {
        numWorkers: this.maxWorkers,
        enableWorkerThreads: true
      });
      this.modules = await Promise.all(compilation.modules.map(async webpackModule => {
        const renderedModule = compilation.moduleTemplates.javascript.render(webpackModule, compilation.dependencyTemplates, compilation.options).sourceAndMap();

        if (typeof webpackModule.id === 'string') {
          moduleMappings.modules[webpackModule.id] = webpackModule.index;
        }

        let code = `__haul_${this.bundleName}.l(${variableToString(webpackModule.id)}, ${renderedModule.source});`;
        let map = renderedModule.map;

        if (this.minify) {
          const minifyOptionsWithMap = { ...this.minifyOptions,
            sourceMap: {
              content: map
            }
          }; // @ts-ignore property minify does not exist on type 'JestWorker'

          const minifiedSource = await minifyWorker.minify(code, minifyOptionsWithMap); //Check if there is no error in minifed source

          (0, _assert.default)(!minifiedSource.error, minifiedSource.error);
          code = minifiedSource.code || '';

          if (typeof minifiedSource.map === 'string') {
            map = JSON.parse(minifiedSource.map);
          }
        }

        return {
          id: webpackModule.id,
          idx: webpackModule.index,
          filename: webpackModule.resource,
          source: code,
          map: { ...map,
            file: `${typeof webpackModule.id === 'string' ? webpackModule.index : webpackModule.id}.js`
          }
        };
      }));
      minifyWorker.end();

      const indent = line => `/*****/  ${line}`;

      let bootstrap = _fs.default.readFileSync(_path.default.join(__dirname, '../../../../runtime/webpack/plugin/ram-bundle-webpack-plugin/bootstrap.js'), 'utf8');

      if (typeof this.bundleName !== 'string' || !this.bundleName.length) {
        throw new Error('RamBundleWebpackPlugin: bundle name cannot be empty string');
      }

      bootstrap = `(${bootstrap.trim()})(this, ${(0, _util.inspect)({
        bundleName: this.bundleName,
        bundleId: this.bundleId,
        mainModuleId: mainId,
        preloadBundleNames: this.preloadBundles,
        singleBundleMode: this.singleBundleMode,
        moduleMappings
      }, {
        depth: null,
        maxArrayLength: null,
        breakLength: Infinity
      })});`.split('\n').map(indent).join('\n') + '\n'; // Enhance bootstrapCode with additional JS from plugins that hook
      // into `renderWithEntry` for example: webpack's `library` is used here to expose
      // bundle as a library.

      const renderWithEntryResults = compilation.mainTemplate.hooks.renderWithEntry.call(bootstrap, mainChunk, mainChunk.hash);

      if (typeof renderWithEntryResults === 'string') {
        bootstrap = renderWithEntryResults;
      } else if ('source' in renderWithEntryResults) {
        bootstrap = renderWithEntryResults.source();
      }

      if (this.minify) {
        const {
          error,
          code
        } = _terser.default.minify(bootstrap);

        if (error) {
          throw error;
        }

        bootstrap = code || '';
      }

      const outputFilename = compilation.outputOptions.filename;
      const outputDest = _path.default.isAbsolute(outputFilename) ? outputFilename : _path.default.join(compilation.outputOptions.path, outputFilename);
      const sourceMapFilename = compilation.getPath(compilation.outputOptions.sourceMapFilename, {
        filename: _path.default.isAbsolute(outputFilename) ? _path.default.relative(compilation.context, outputFilename) : outputFilename
      });
      const bundle = this.indexRamBundle ? new _IndexRamBundle.default(bootstrap, this.modules, this.sourceMap) : new _FileRamBundle.default(bootstrap, this.modules, this.sourceMap, this.bundleName, this.singleBundleMode);
      const filesToRemove = compilation.chunks.reduce((acc, chunk) => {
        if (chunk.name !== 'main') {
          return [...acc, ...chunk.files];
        }

        return acc;
      }, []);
      Object.keys(compilation.assets).forEach(assetName => {
        const remove = filesToRemove.some(file => assetName.endsWith(file));

        if (remove) {
          delete compilation.assets[assetName];
        }
      });
      bundle.build({
        outputDest,
        outputFilename,
        sourceMapFilename,
        compilation
      });
    });
  }

}

exports.default = RamBundleWebpackPlugin;
//# sourceMappingURL=RamBundleWebpackPlugin.js.map