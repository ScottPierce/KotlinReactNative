"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _magicNumber = _interopRequireDefault(require("metro/src/shared/output/RamBundle/magic-number"));

var _webpackSources = require("webpack-sources");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/***
 * Reference: https://github.com/facebook/metro/blob/master/packages/metro/src/shared/output/RamBundle/as-indexed-file.js
 */
const NULL_TERMINATOR = Buffer.alloc(1).fill(0);
const UNIT32_SIZE = 4;

class IndexRamBundle {
  constructor(bootstrap, modules, sourceMap = false) {
    this.sourceMap = sourceMap;

    _defineProperty(this, "encoding", 'utf8');

    _defineProperty(this, "header", Buffer.alloc(4));

    _defineProperty(this, "bootstrap", Buffer.alloc(0));

    _defineProperty(this, "toc", Buffer.alloc(0));

    _defineProperty(this, "modules", []);

    _defineProperty(this, "rawModules", []);

    this.bootstrap = this.toNullTerminatedBuffer(bootstrap);
    this.rawModules = modules;
    this.modules = modules.map(m => ({
      id: typeof m.id === 'string' ? m.idx : m.id,
      buffer: this.toNullTerminatedBuffer(m.source)
    }));
    this.header.writeUInt32LE(_magicNumber.default, 0);
  }

  toNullTerminatedBuffer(body) {
    return Buffer.concat([Buffer.from(body, this.encoding), NULL_TERMINATOR]);
  }

  getOffset(n) {
    return (2 + n * 2) * UNIT32_SIZE;
  }

  buildToc() {
    const maxModuleId = Math.max(...this.modules.map(m => m.id));
    const entriesLength = maxModuleId + 1;
    const table = Buffer.alloc(this.getOffset(entriesLength)).fill(0);
    table.writeUInt32LE(entriesLength, 0);
    table.writeUInt32LE(this.bootstrap.length, UNIT32_SIZE);
    let codeOffset = this.bootstrap.length;
    this.modules.forEach(moduleBuffer => {
      const offset = this.getOffset(moduleBuffer.id);
      table.writeUInt32LE(codeOffset, offset);
      table.writeUInt32LE(moduleBuffer.buffer.length, offset + UNIT32_SIZE);
      codeOffset += moduleBuffer.buffer.length;
    });
    this.toc = table;
  }

  build({
    outputDest,
    outputFilename,
    sourceMapFilename,
    compilation
  }) {
    this.buildToc();
    const bundle = Buffer.concat([this.header, this.toc, this.bootstrap].concat(this.modules.map(m => m.buffer))); // Cast buffer to any to avoid mismatch of types. RawSource works not only on strings
    // but also on Buffers.

    compilation.assets[outputFilename] = new _webpackSources.RawSource(bundle);

    if (this.sourceMap) {
      const indexMap = {
        version: 3,
        file: outputDest,
        sections: []
      };
      this.rawModules.forEach((sourceModule, index) => {
        indexMap.sections.push({
          offset: {
            line: index,
            column: 0
          },
          map: sourceModule.map
        });
      });
      compilation.assets[sourceMapFilename] = new _webpackSources.RawSource(JSON.stringify(indexMap));
    }
  }

}

exports.default = IndexRamBundle;
//# sourceMappingURL=IndexRamBundle.js.map