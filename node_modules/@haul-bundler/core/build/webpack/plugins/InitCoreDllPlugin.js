"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _DllEntryDependency = _interopRequireDefault(require("webpack/lib/dependencies/DllEntryDependency"));

var _DllModuleFactory = _interopRequireDefault(require("webpack/lib/DllModuleFactory"));

var _DllModule = _interopRequireDefault(require("webpack/lib/DllModule"));

var _webpackSources = require("webpack-sources");

var _enhancedResolve = require("enhanced-resolve");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class InitCoreDllModule extends _DllModule.default {
  constructor(context, dependencies, name, type, getInitCoreSource) {
    super(context, dependencies, name, type);
    this.getInitCoreSource = getInitCoreSource;
  }

  source() {
    return new _webpackSources.RawSource(`${this.getInitCoreSource()}\nmodule.exports = __webpack_require__;`);
  }

}

class InitCoreDllModuleFactory extends _DllModuleFactory.default {
  constructor(getInitCoreSource) {
    super();
    this.getInitCoreSource = getInitCoreSource;
  }

  create(data, callback) {
    const dependency = data.dependencies[0];
    callback(null, new InitCoreDllModule(data.context, dependency.dependencies, dependency.name, dependency.type, this.getInitCoreSource));
  }

}

class InitCoreDllPlugin {
  constructor({
    setupFiles
  }) {
    _defineProperty(this, "setupFiles", []);

    _defineProperty(this, "resolvedSetupFiles", []);

    this.setupFiles = setupFiles;
  }

  apply(compiler) {
    compiler.hooks.beforeRun.tapPromise('InitCoreDllPlugin', async compiler => {
      const resolver = _enhancedResolve.ResolverFactory.createResolver({ ...compiler.options.resolve,
        fileSystem: compiler.inputFileSystem
      });

      this.resolvedSetupFiles = await Promise.all(this.setupFiles.map(async setupFile => new Promise((resolve, reject) => {
        resolver.resolve({}, compiler.context, setupFile, (error, resolved) => {
          if (error) {
            reject(error);
          } else {
            resolve(resolved);
          }
        });
      })));
    });
    compiler.hooks.compilation.intercept({
      register: tap => {
        // Intercept tap from DllEntryPlugin in order to modify it.
        // The modified tap function, will call original DllEntryPlugin tap function,
        // and then overwrite the DllEntryDependency value in compilation.dependencyFactories
        // with custom one.
        if (tap.name === 'DllEntryPlugin') {
          return { ...tap,
            fn: (compilation, ...args) => {
              tap.fn(compilation, ...args);
              const initCoreDllModuleFactory = new InitCoreDllModuleFactory(() => {
                const setupFilesModulesIds = compilation.modules.reduce((acc, webpackModule) => {
                  if (this.resolvedSetupFiles.some(setupFile => webpackModule.resource === setupFile)) {
                    return { ...acc,
                      [webpackModule.resource]: webpackModule.id
                    };
                  }

                  return acc;
                }, {});
                const setupCode = this.resolvedSetupFiles.filter(resolvedSetupFile => setupFilesModulesIds[resolvedSetupFile]).map(resolvedSetupFile => `__webpack_require__(${JSON.stringify(setupFilesModulesIds[resolvedSetupFile])});`).join('\n');
                return setupCode;
              });
              compilation.dependencyFactories.set(_DllEntryDependency.default, initCoreDllModuleFactory);
            }
          };
        }

        return tap;
      }
    });
  }

}

exports.default = InitCoreDllPlugin;
//# sourceMappingURL=InitCoreDllPlugin.js.map