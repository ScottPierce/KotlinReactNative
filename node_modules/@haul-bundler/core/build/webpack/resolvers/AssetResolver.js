"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _path = _interopRequireDefault(require("path"));

var _escapeStringRegexp = _interopRequireDefault(require("escape-string-regexp"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class AssetResolver {
  static collect(list, {
    name,
    type,
    platform
  }) {
    const regex = /^(bmp|gif|jpg|jpeg|png|psd|tiff|webp|svg)$/.test(type) ? new RegExp(`^${(0, _escapeStringRegexp.default)(name)}(@\\d+(\\.\\d+)?x)?(\\.(${platform}|native))?\\.${type}$`) : new RegExp(`^${(0, _escapeStringRegexp.default)(name)}(\\.(${platform}|native))?\\.${type}$`);

    const priority = queryPlatform => ['native', platform].indexOf(queryPlatform); // Build a map of files according to the scale


    return list.reduce((acc, curr) => {
      const match = regex.exec(curr);

      if (match) {
        let [, scale,,, platform] = match;
        scale = scale || '@1x';

        if (acc[scale] && priority(platform) < priority(acc[scale].platform)) {
          // do nothing
          return acc;
        }

        return { ...acc,
          [scale]: {
            platform,
            name: curr
          }
        };
      }

      return acc;
    }, {});
  }

  constructor(options) {
    this.options = options;
  }

  apply(resolver) {
    const platform = this.options.platform;
    const test = this.options.test || AssetResolver.test;
    const runtime = this.options.runtime;
    resolver.hooks.file.tapAsync('AssetResolver', (request, _, callback) => {
      if (!test.test(request.path)) {
        callback();
        return;
      }

      resolver.fileSystem.readdir(_path.default.dirname(request.path), (error, result) => {
        if (error) {
          callback();
          return;
        }

        const name = _path.default.basename(request.path).replace(/\.[^.]+$/, '');

        const type = request.path.split('.').pop() || '';
        let resolved = result.includes(_path.default.basename(request.path)) ? request.path : null;

        if (!resolved) {
          const map = AssetResolver.collect(result, {
            name,
            type,
            platform
          });
          const key = map['@1x'] ? '@1x' : Object.keys(map).sort((a, b) => Number(a.replace(/[^\d.]/g, '')) - Number(b.replace(/[^\d.]/g, '')))[0];
          resolved = map[key] && map[key].name ? _path.default.resolve(_path.default.dirname(request.path), map[key].name) : null;
        }

        if (!resolved) {
          runtime.logger.warn(`Cannot resolve: ${request.path}`);
          callback();
          return;
        }

        const resolvedFile = { ...request,
          path: resolved,
          relativePath: request.relativePath && resolver.join(request.relativePath, resolved),
          file: true
        };
        runtime.logger.debug(`Resolved file: ${request.path} <--> ${resolvedFile.path}`);
        callback(null, resolvedFile);
      });
    });
  }

}

exports.default = AssetResolver;

_defineProperty(AssetResolver, "test", /\.(aac|aiff|bmp|caf|gif|html|jpeg|jpg|m4a|m4v|mov|mp3|mp4|mpeg|mpg|obj|otf|pdf|png|psd|svg|ttf|wav|webm|webp)$/);
//# sourceMappingURL=AssetResolver.js.map