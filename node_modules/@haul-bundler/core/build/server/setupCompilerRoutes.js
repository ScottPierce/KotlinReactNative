"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = setupCompilerRoutes;

var _boom = _interopRequireDefault(require("@hapi/boom"));

var _joi = _interopRequireDefault(require("@hapi/joi"));

var _Compiler = _interopRequireDefault(require("@haul-bundler/core-legacy/build/compiler/Compiler"));

var _runAdbReverse = _interopRequireDefault(require("../utils/runAdbReverse"));

var _createDeltaBundle = _interopRequireDefault(require("./createDeltaBundle"));

var _getBundleDataFromURL = _interopRequireDefault(require("../utils/getBundleDataFromURL"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// @ts-ignore
function setupCompilerRoutes(runtime, server, compiler, {
  port,
  bundleNames,
  platforms,
  cliBundleOptions
}) {
  let hasRunAdbReverse = false;
  let hasWarnedDelta = false;
  const bundleRegex = /^([^.]+)(\.[^.]+)?\.(bundle|delta)$/;
  let bundleOptions = {
    ios: { ...cliBundleOptions
    },
    android: { ...cliBundleOptions
    }
  };
  server.route({
    method: 'GET',
    path: '/{any*}',
    options: {
      validate: {
        query: _joi.default.object({
          platform: _joi.default.string(),
          minify: _joi.default.boolean(),
          dev: _joi.default.boolean()
        }).unknown(true)
      }
    },
    handler: async (request, h) => {
      if (!bundleRegex.test(request.path)) {
        return new Promise(resolve => {
          const filename = request.path;
          compiler.emit(_Compiler.default.Events.REQUEST_FILE, {
            filename,
            callback: result => {
              resolve(makeResponseFromCompilerResults(h, {
                filename
              }, result));
            }
          });
        });
      } else {
        const {
          name: bundleName,
          platform,
          type: bundleType
        } = (0, _getBundleDataFromURL.default)(request.url.href);

        if (!platform) {
          const message = `Cannot detect platform parameter in URL: ${request.path}`;
          runtime.logger.error(message);
          return _boom.default.badImplementation(message);
        }

        if (!platforms.includes(platform)) {
          const message = `Platform "${platform}" is not supported - only: ${platforms.map(platform => `"${platform}"`).join(', ')} are available.`;
          runtime.logger.error(message);
          return _boom.default.badRequest(message);
        }

        runtime.logger.info(`Compiling ${bundleType === 'bundle' ? bundleType : `${bundleType} bundle`} "${bundleName}" for platform ${platform}`);

        if (!hasRunAdbReverse && platform === 'android') {
          hasRunAdbReverse = true;
          await (0, _runAdbReverse.default)(runtime, port);
        }

        if (bundleType === 'delta' && !hasWarnedDelta) {
          runtime.logger.warn('Your app requested a delta bundle, this has minimal support in Haul');
          hasWarnedDelta = true;
        }

        const bundleOptionsFromQuery = getBundleOptionsFromQuery(request.query);
        const isUserChangedOptions = isUserChangedAlreadySetBundleOptions(bundleOptions[platform], bundleOptionsFromQuery);

        if (isUserChangedOptions) {
          const warnMsg = 'Changing query params after the bundle has been created is not supported. To see the changes you need to restart the Haul server.';
          runtime.logger.warn(warnMsg);
          return h.response(warnMsg).code(501);
        }

        if (areBundleOptionsSet(bundleOptionsFromQuery)) {
          bundleOptions[platform] = { ...bundleOptions[platform],
            ...bundleOptionsFromQuery,
            alreadySet: true
          };
        }

        const bundleOptionsForCompiler = {
          minify: bundleOptions[platform].minify,
          dev: bundleOptions[platform].dev
        };
        return new Promise(resolve => {
          const filename = `${bundleName}.${platform}.bundle`;
          compiler.emit(_Compiler.default.Events.REQUEST_BUNDLE, {
            bundleOptions: bundleOptionsForCompiler,
            filename,
            platform,
            callback: result => {
              resolve(makeResponseFromCompilerResults(h, {
                filename,
                bundleType,
                bundleNames
              }, result));
            }
          });
        });
      }
    }
  });
}

function makeResponseFromCompilerResults(h, {
  filename,
  bundleType,
  bundleNames
}, result) {
  if (result.errors) {
    return h.response({
      errors: result.errors
    }).code(500);
  } else if (!result.file) {
    return _boom.default.notFound(`File ${filename} not found`);
  }

  let file;

  if (bundleType === 'delta') {
    // We have a bundle, but RN is expecting a delta bundle.
    // Convert full bundle into the simplest delta possible.
    // This will load slower in RN, but it won't error, which is
    // nice for automated use-cases where changing the dev setting
    // is not possible.
    file = (0, _createDeltaBundle.default)(result.file.toString());
  } else {
    file = result.file.type === 'Buffer' ? Buffer.from(result.file.data) : result.file;
  }

  const response = h.response(file).type(result.mimeType).code(200); // Add bundle names when running in multi-bundle mode.

  if (bundleNames && bundleNames.length > 1) {
    response.header('X-multi-bundle', bundleNames.filter(name => !filename.includes(name)).join(','));
  }

  return response;
}

function areBundleOptionsSet(bundleOptions) {
  return bundleOptions.dev !== undefined || bundleOptions.minify !== undefined;
}

function getBundleOptionsFromQuery(query) {
  let bundleOptions = {};

  if (query.minify === true) {
    bundleOptions.minify = true;
  } else if (query.minify === false) {
    bundleOptions.minify = false;
  }

  if (query.dev === true) {
    bundleOptions.dev = true;
  } else if (query.dev === false) {
    bundleOptions.dev = false;
  }

  return bundleOptions;
}

function isUserChangedAlreadySetBundleOptions(bundleOptions, bundleOptionsFromQuery) {
  if (areBundleOptionsSet(bundleOptionsFromQuery)) {
    if (bundleOptions.alreadySet) {
      return bundleOptions.dev !== bundleOptionsFromQuery.dev || bundleOptionsFromQuery.minify !== bundleOptions.minify;
    }
  }

  return false;
}
//# sourceMappingURL=setupCompilerRoutes.js.map