{"version":3,"sources":["../../src/server/setupSymbolication.ts"],"names":["getRequestedFrames","payload","stack","newStack","filter","stackLine","methodName","unwantedStackRegExp","RegExp","test","evalLine","indexOf","newMethodName","slice","sourceMapConsumers","getSourceMapConsumers","runtime","platform","bundleNames","baseUrl","Promise","all","map","bundleName","createSourceMapConsumer","reduce","acc","sourceMapConsumer","index","logger","info","join","url","response","sourceMap","text","warn","undefined","SourceMapConsumer","err","error","setupSymbolication","server","route","method","path","options","validate","Joi","array","items","any","handler","request","h","unconvertedFrames","length","code","file","consumers","host","split","convertedFrames","originalFrame","lineNumber","column","name","targetConsumer","lookup","originalPositionFor","line","source"],"mappings":"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","sourcesContent":["import Hapi from '@hapi/hapi';\nimport Joi from '@hapi/joi';\nimport Runtime from '../runtime/Runtime';\nimport { SourceMapConsumer } from 'source-map';\nimport fetch from 'node-fetch';\nimport getBundleDataFromURL from '../utils/getBundleDataFromURL';\n\ntype ReactNativeStackFrame = {\n  lineNumber: number;\n  column: number;\n  file: string;\n  methodName: string;\n};\n\ntype ReactNativeStack = Array<ReactNativeStackFrame>;\n\ntype ReactNativeSymbolicatePayload = {\n  stack: ReactNativeStack;\n};\n\n/**\n * Gets the stack frames that React Native wants us to convert.\n */\nfunction getRequestedFrames(\n  payload: ReactNativeSymbolicatePayload\n): ReactNativeStack | null {\n  const stack = payload.stack;\n  if (!stack) return null;\n\n  const newStack = stack.filter(stackLine => {\n    const { methodName } = stackLine;\n    const unwantedStackRegExp = new RegExp(\n      /(__webpack_require__|haul|eval(JS){0,1})/\n    );\n\n    if (unwantedStackRegExp.test(methodName)) return false; // we don't need those\n\n    const evalLine = methodName.indexOf('Object../');\n    if (evalLine > -1) {\n      const newMethodName = methodName.slice(evalLine + 9); // removing this prefix in method names\n      stackLine.methodName = newMethodName; // eslint-disable-line\n    }\n    return true;\n  });\n\n  return newStack;\n}\n\ntype SourceMapConsumers = {\n  [platform: string]: {\n    [bundleName: string]: SourceMapConsumer | undefined;\n  };\n};\n\nlet sourceMapConsumers: SourceMapConsumers = {};\n\nasync function getSourceMapConsumers(\n  runtime: Runtime,\n  platform: string,\n  bundleNames: string[],\n  baseUrl: string\n): Promise<SourceMapConsumers> {\n  if (!sourceMapConsumers[platform]) {\n    // eslint-disable-next-line require-atomic-updates\n    sourceMapConsumers[platform] = (\n      await Promise.all(\n        bundleNames.map(bundleName =>\n          createSourceMapConsumer(\n            runtime,\n            `${baseUrl}${bundleName}.${platform}.bundle.map`\n          )\n        )\n      )\n    ).reduce(\n      (acc, sourceMapConsumer, index) => ({\n        ...acc,\n        [bundleNames[index]]: sourceMapConsumer,\n      }),\n      {}\n    );\n\n    runtime.logger.info(\n      `Source map consumers for ${platform} bundles: ${bundleNames.join(\n        ', '\n      )} created`\n    );\n  }\n\n  return sourceMapConsumers;\n}\n\n/**\n * Creates a SourceMapConsumer so we can query it.\n */\nasync function createSourceMapConsumer(runtime: Runtime, url: string) {\n  const response = await fetch(url);\n  const sourceMap = await response.text();\n\n  // we stop here if we couldn't find that map\n  if (!sourceMap) {\n    runtime.logger.warn('Unable to find source map.');\n    return undefined;\n  }\n\n  // feed the raw source map into our consumer\n  try {\n    return new SourceMapConsumer(sourceMap);\n  } catch (err) {\n    runtime.logger.error('There was a problem reading the source map', err);\n    return undefined;\n  }\n}\n\nexport default function setupSymbolication(\n  runtime: Runtime,\n  server: Hapi.Server,\n  { bundleNames }: { bundleNames: string[] }\n) {\n  server.route({\n    method: 'POST',\n    path: '/symbolicate',\n    options: {\n      validate: {\n        payload: {\n          stack: Joi.array().items(Joi.any()),\n        },\n      },\n    },\n    handler: async (request, h) => {\n      // grab the source stack frames\n      const unconvertedFrames = getRequestedFrames(\n        request.payload as ReactNativeSymbolicatePayload\n      );\n      if (!unconvertedFrames || unconvertedFrames.length === 0) {\n        runtime.logger.warn('Cannot symbolicate an empty stack frames');\n        return h.response().code(400);\n      }\n\n      const { platform } = getBundleDataFromURL(unconvertedFrames[0].file);\n      if (!platform) {\n        runtime.logger.warn(\n          `Cannot detect platform from initial frame: ${unconvertedFrames[0].file}`\n        );\n        return h.response().code(400);\n      }\n\n      // grab our source map consumer\n      const consumers = await getSourceMapConsumers(\n        runtime,\n        platform,\n        bundleNames,\n        `http://localhost:${request.info.host.split(':')[1]}/`\n      );\n\n      if (!consumers || !consumers[platform]) {\n        runtime.logger.error('No source map consumers were created');\n        return h.response().code(500);\n      }\n\n      let convertedFrames: ReactNativeStackFrame[] = [];\n      try {\n        // error error on the wall, who's the fairest stack of all?\n        convertedFrames = unconvertedFrames.map(\n          (originalFrame): ReactNativeStackFrame => {\n            if (\n              originalFrame.lineNumber === null ||\n              originalFrame.column === null\n            ) {\n              return originalFrame;\n            }\n\n            const { name: bundleName } = getBundleDataFromURL(\n              originalFrame.file\n            );\n            if (!bundleName) {\n              return originalFrame;\n            }\n\n            const targetConsumer = consumers[platform][bundleName];\n            if (!targetConsumer) {\n              runtime.logger.warn(\n                `SourceMapConsumer for ${bundleName} was not initialized`\n              );\n              return originalFrame;\n            }\n\n            // find the original home of this line of code.\n            const lookup = targetConsumer.originalPositionFor({\n              line: originalFrame.lineNumber,\n              column: originalFrame.column,\n            });\n\n            // If lookup fails, we get the same shape object, but with\n            // all values set to null\n            if (lookup.source == null) {\n              // It is better to gracefully return the original frame\n              // than to throw an exception\n              return originalFrame;\n            }\n\n            // convert these to a format which React Native wants\n            return {\n              lineNumber: lookup.line || originalFrame.lineNumber,\n              column: lookup.column || originalFrame.column,\n              file: lookup.source,\n              methodName: originalFrame.methodName,\n            };\n          }\n        );\n      } catch (error) {\n        runtime.logger.error(error);\n      }\n\n      // send it back to React Native\n      return { stack: convertedFrames };\n    },\n  });\n}\n"],"file":"setupSymbolication.js"}