"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _hapi = _interopRequireDefault(require("@hapi/hapi"));

var _http = _interopRequireDefault(require("http"));

var _ws = _interopRequireDefault(require("ws"));

var _Compiler = _interopRequireDefault(require("@haul-bundler/core-legacy/build/compiler/Compiler"));

var _terminalKit = require("terminal-kit");

var _setupDevtoolRoutes = _interopRequireDefault(require("./setupDevtoolRoutes"));

var _setupCompilerRoutes = _interopRequireDefault(require("./setupCompilerRoutes"));

var _setupLiveReload = _interopRequireDefault(require("./setupLiveReload"));

var _setupSymbolication = _interopRequireDefault(require("./setupSymbolication"));

var _websocketProxy = _interopRequireDefault(require("./websocketProxy"));

var _WebSocketDebuggerProxy = _interopRequireDefault(require("./WebSocketDebuggerProxy"));

var _InteractiveUI = _interopRequireDefault(require("./InteractiveUI"));

var _NonInteractiveUI = _interopRequireDefault(require("./NonInteractiveUI"));

var _Logger = _interopRequireDefault(require("../runtime/Logger"));

var _ansiFragments = require("ansi-fragments");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Server {
  constructor(runtime, configPath, options) {
    this.runtime = runtime;
    this.configPath = configPath;
    this.options = options;

    _defineProperty(this, "compiler", void 0);

    _defineProperty(this, "server", void 0);

    _defineProperty(this, "httpServer", _http.default.createServer());

    _defineProperty(this, "resetConsole", () => {});

    _defineProperty(this, "disposeLoggerProxy", () => {});

    _defineProperty(this, "ui", void 0);

    if (this.options.noInteractive) {
      this.ui = new _NonInteractiveUI.default(this.runtime);
    } else {
      this.ui = new _InteractiveUI.default(_terminalKit.terminal);
    }
  }

  createCompiler() {
    const compiler = new _Compiler.default({
      configPath: this.configPath,
      configOptions: { ...this.options,
        bundleTarget: 'server',
        bundleMode: this.options.bundleNames.length > 1 ? 'multi-bundle' : 'single-bundle'
      }
    }, this.runtime.logger);
    compiler.on(_Compiler.default.Events.BUILD_START, ({
      platform
    }) => {
      this.ui.updateCompilationProgress(platform, {
        running: true,
        value: 0
      });
    });
    compiler.on(_Compiler.default.Events.BUILD_PROGRESS, ({
      progress,
      platform
    }) => {
      this.ui.updateCompilationProgress(platform, {
        running: true,
        value: progress
      });
    });
    compiler.on(_Compiler.default.Events.BUILD_FAILED, ({
      platform,
      message
    }) => {
      this.ui.updateCompilationProgress(platform, {
        running: false,
        value: 0
      });
      this.ui.addLogItem(this.runtime.logger.enhanceWithLevel(_Logger.default.Level.Error, message));
    });
    compiler.on(_Compiler.default.Events.BUILD_FINISHED, ({
      platform,
      errors
    }) => {
      this.ui.updateCompilationProgress(platform, {
        running: false,
        value: 1
      });
      errors.forEach(error => {
        this.ui.addLogItem(this.runtime.logger.enhanceWithLevel(_Logger.default.Level.Error, error));
      });
    });
    return compiler;
  }

  attachProcessEventsListeners() {
    const createListener = exitCode => error => {
      this.exit(exitCode, error);
    }; // Manually call disposal logic if pressed key is CTRL + C.
    // 'SIGINT' signal won't be emitted on CTRL + C, because stdin is in raw mode.


    _terminalKit.terminal.on('key', name => {
      if (name === 'CTRL_C') {
        createListener(0)(null);
      }
    });

    process.on('uncaughtException', createListener(1));
    process.on('unhandledRejection', createListener(1));
    process.on('SIGINT', createListener(0));
    process.on('SIGTERM', createListener(2));
  }

  exit(exitCode, error) {
    this.ui.dispose(exitCode, false);
    this.resetConsole();
    this.disposeLoggerProxy();
    this.compiler.terminate();

    if (error) {
      this.runtime.logger.error(error);
    }

    this.runtime.complete(exitCode);
  }

  async listen(host, port) {
    // Proxy logs from runtime to interactive server UI only when server is running
    // in interactive mode.
    if (!this.options.noInteractive) {
      this.disposeLoggerProxy = this.runtime.logger.proxy((level, ...args) => {
        this.ui.addLogItem(this.runtime.logger.enhanceWithLevel(level, ...args));
      });
    }

    this.resetConsole = this.hijackConsole();
    this.compiler = this.createCompiler();
    this.attachProcessEventsListeners();
    const server = new _hapi.default.Server({
      port,
      host,
      router: {
        stripTrailingSlash: true
      }
    });
    const webSocketServer = new _ws.default.Server({
      server: server.listener
    });
    const webSocketProxy = (0, _websocketProxy.default)(webSocketServer, '/debugger-proxy');
    const debuggerProxy = new _WebSocketDebuggerProxy.default(this.runtime, webSocketProxy);
    await server.register(require('@hapi/inert'));
    server.events.on('response', request => {
      if ('statusCode' in request.response) {
        if (request.response.statusCode < 400) {
          this.logServerEvent(request);
        } else {
          this.logServerEvent(request);
        }
      }
    });
    (0, _setupSymbolication.default)(this.runtime, server, {
      bundleNames: this.options.bundleNames
    });
    (0, _setupLiveReload.default)(this.runtime, server, this.compiler);
    (0, _setupDevtoolRoutes.default)(this.runtime, server, {
      isDebuggerConnected: () => debuggerProxy.isDebuggerConnected()
    });
    (0, _setupCompilerRoutes.default)(this.runtime, server, this.compiler, {
      port,
      bundleNames: this.options.bundleNames,
      platforms: this.options.platforms,
      cliBundleOptions: {
        minify: this.options.minify,
        dev: this.options.dev
      }
    });
    await server.start();
    this.ui.start(this.options.platforms);
    this.runtime.logger.done(`Packager server running on http://${host}:${port}`);
    this.options.eager.forEach(platform => {
      this.compiler.emit(_Compiler.default.Events.REQUEST_BUNDLE, {
        filename: `/index.${platform}.bundle`,
        // NOTE: maybe the entry bundle is arbitrary
        platform,

        callback() {}

      });
    });
  }

  hijackConsole() {
    if (this.options.noInteractive) {
      return () => {};
    }
    /* eslint-disable no-console */


    const log = console.log;
    const error = console.error;

    console.log = (...args) => {
      this.ui.addLogItem(this.runtime.logger.enhanceWithLevel(_Logger.default.Level.Info, ...args));
    };

    console.error = (...args) => {
      this.ui.addLogItem(this.runtime.logger.enhanceWithLevel(_Logger.default.Level.Error, ...args));
    };

    return () => {
      console.log = log;
      console.error = error;
    };
    /* eslint-enable no-console */
  }

  logServerEvent(request, event) {
    const {
      statusCode
    } = request.response;
    let logColor = 'green';
    let level = 'info';

    if (statusCode >= 300 && statusCode < 400) {
      logColor = 'yellow';
      level = 'warn';
    } else if (statusCode >= 400) {
      logColor = 'red';
      level = 'error';
    }

    this.runtime.logger[level]((0, _ansiFragments.container)((0, _ansiFragments.color)(logColor, (0, _ansiFragments.modifier)('bold', request.method.toUpperCase())), (0, _ansiFragments.pad)(1), request.path, (0, _ansiFragments.pad)(1), (0, _ansiFragments.color)('gray', statusCode.toString()), event ? event.tags.join(' ') : '').build());
  }

}

exports.default = Server;
//# sourceMappingURL=Server.js.map