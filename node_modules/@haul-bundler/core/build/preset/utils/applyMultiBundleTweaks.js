"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getBundleFilename = getBundleFilename;
exports.default = applyMultiBundleTweaks;

var _path = _interopRequireDefault(require("path"));

var _webpack = _interopRequireDefault(require("webpack"));

var _compileTemplate = _interopRequireDefault(require("./compileTemplate"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getBundleFilename(env, templatesConfig, bundleConfig) {
  return (0, _compileTemplate.default)(templatesConfig.filename[env.bundleTarget === 'server' ? '__server__' : bundleConfig.platform], {
    bundleName: bundleConfig.name,
    platform: bundleConfig.platform,
    type: bundleConfig.dll ? 'dll' : bundleConfig.app ? 'app' : 'default',
    mode: bundleConfig.dev ? 'dev' : 'prod'
  });
}

function applyMultiBundleTweaks(env, templatesConfig, bundleConfig, webpackConfig, normalizedBundleConfigs) {
  let bundleFilename = getBundleFilename(env, templatesConfig, bundleConfig);
  let bundleOutputDirectory = webpackConfig.output.path;

  if (env.bundleOutput) {
    // `bundleOutput` should be a directory, but for backward-compatibility,
    // we also handle the case with a filename.
    bundleOutputDirectory = _path.default.extname(env.bundleOutput) === '' ? env.bundleOutput : _path.default.dirname(env.bundleOutput);
    bundleOutputDirectory = _path.default.isAbsolute(bundleOutputDirectory) ? bundleOutputDirectory : _path.default.join(bundleConfig.root, bundleOutputDirectory);

    const targetBundleOutput = _path.default.join(bundleOutputDirectory, bundleFilename);

    webpackConfig.output.filename = _path.default.relative(webpackConfig.output.path, targetBundleOutput);
  } else {
    webpackConfig.output.filename = bundleFilename;
  }

  if (bundleConfig.dll) {
    webpackConfig.output.library = bundleConfig.name;
    webpackConfig.output.libraryTarget = 'this';
    webpackConfig.plugins.push(new _webpack.default.DllPlugin({
      name: bundleConfig.name,
      path: _path.default.join(bundleOutputDirectory, `${bundleConfig.name}.manifest.json`)
    }));
  } else if (bundleConfig.app) {
    webpackConfig.output.library = bundleConfig.name;
    webpackConfig.output.libraryTarget = 'this';
  }

  bundleConfig.dependsOn.forEach(dllBundleName => {
    const dllNormalizedBundleConfig = normalizedBundleConfigs[dllBundleName];

    if (!dllNormalizedBundleConfig) {
      throw new Error(`Cannot find bundle config for DLL '${dllBundleName}' - make sure it's listed in config before any other bundle depends on it.`);
    }

    webpackConfig.plugins.push(new _webpack.default.DllReferencePlugin({
      context: bundleConfig.root,
      manifest: dllNormalizedBundleConfig.external ? dllNormalizedBundleConfig.external.manifestPath : _path.default.join(bundleOutputDirectory, `${dllBundleName}.manifest.json`),
      sourceType: 'this'
    }));
  });
}
//# sourceMappingURL=applyMultiBundleTweaks.js.map