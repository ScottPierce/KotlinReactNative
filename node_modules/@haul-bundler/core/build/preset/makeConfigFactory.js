"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = makeConfigFactory;

var _lodash = _interopRequireDefault(require("lodash.get"));

var _lodash2 = _interopRequireDefault(require("lodash.merge"));

var _webpack = _interopRequireDefault(require("webpack"));

var _path = _interopRequireDefault(require("path"));

var _os = require("os");

var _isCi = _interopRequireDefault(require("is-ci"));

var _ = require("../");

var _getSourceMapPlugin = _interopRequireDefault(require("./utils/getSourceMapPlugin"));

var _applySingleBundleTweaks = _interopRequireDefault(require("./utils/applySingleBundleTweaks"));

var _applyMultiBundleTweaks = _interopRequireDefault(require("./utils/applyMultiBundleTweaks"));

var _LooseModeWebpackPlugin = _interopRequireDefault(require("../webpack/plugins/LooseModeWebpackPlugin"));

var _InitCoreDllPlugin = _interopRequireDefault(require("../webpack/plugins/InitCoreDllPlugin"));

var _RamBundleWebpackPlugin = _interopRequireDefault(require("../webpack/plugins/RamBundleWebpackPlugin"));

var _BasicBundleWebpackPlugin = _interopRequireDefault(require("../webpack/plugins/BasicBundleWebpackPlugin"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const defaultTemplateConfig = {
  filename: {
    ios: '[bundleName].jsbundle',
    android: '[bundleName].[platform].bundle',
    __server__: '[bundleName].[platform].bundle'
  }
};
const defaultFeaturesConfig = {
  multiBundle: 1
};

function makeConfigFactory(getDefaultConfig) {
  return function makeConfig(projectConfig) {
    return (runtime, env) => {
      const normalizedServerConfig = {
        port: env.port || (0, _lodash.default)(projectConfig, 'server.port', _.DEFAULT_PORT),
        host: (0, _lodash.default)(projectConfig, 'server.host', 'localhost')
      };
      const normalizedTemplatesConfig = (0, _lodash2.default)({}, defaultTemplateConfig, projectConfig.templates);
      const featuresConfig = (0, _lodash2.default)({}, defaultFeaturesConfig, projectConfig.features);
      const platforms = projectConfig.platforms || ['ios', 'android'];
      const normalizedBundleConfigs = {};
      const transforms = {};
      const webpackConfigs = {};
      Object.keys(projectConfig.bundles).forEach(bundleName => {
        const bundleConfigBuilder = projectConfig.bundles[bundleName];
        const bundleConfig = typeof bundleConfigBuilder === 'function' ? bundleConfigBuilder(env, runtime) : bundleConfigBuilder;

        let looseMode = () => false;

        if (bundleConfig.looseMode === true) {
          looseMode = () => true;
        } else if (Array.isArray(bundleConfig.looseMode)) {
          looseMode = filename => {
            return bundleConfig.looseMode.some(element => {
              if (typeof element === 'string') {
                if (!_path.default.isAbsolute(element)) {
                  throw new Error(`${element} in 'looseMode' property must be an absolute path or regex`);
                }

                return element === filename;
              }

              return element.test(filename);
            });
          };
        } else if (typeof bundleConfig.looseMode === 'function') {
          looseMode = bundleConfig.looseMode;
        } // TODO: use minifyOptions to configure terser for basic bundle


        const dev = bundleConfig.dev || env.dev;
        const root = bundleConfig.root || env.root;
        const normalizedBundleConfig = {
          name: bundleConfig.name || bundleName,
          entry: typeof bundleConfig.entry === 'string' ? {
            entryFiles: [bundleConfig.entry],
            setupFiles: []
          } : Array.isArray(bundleConfig.entry) ? {
            entryFiles: bundleConfig.entry,
            setupFiles: []
          } : bundleConfig.entry || {
            setupFiles: [],
            entryFiles: []
          },
          type: // Force basic-bundle type when serving from packager server.
          env.bundleTarget === 'server' ? 'basic-bundle' : bundleConfig.type || env.bundleType || 'basic-bundle',
          platform: bundleConfig.platform || env.platform,
          root,
          dev,
          assetsDest: bundleConfig.assetsDest || env.assetsDest || '',
          minify: bundleConfig.minify || Boolean(env.minify),
          minifyOptions: bundleConfig.minifyOptions || undefined,
          sourceMap: typeof bundleConfig.sourceMap !== 'undefined' ? bundleConfig.sourceMap : true,
          looseMode,
          app: Boolean(bundleConfig.app),
          dll: Boolean(bundleConfig.dll),
          dependsOn: bundleConfig.dependsOn || [],
          external: bundleConfig.bundlePath ? {
            copyBundle: Boolean(bundleConfig.copyBundle),
            bundlePath: bundleConfig.bundlePath,
            assetsPath: bundleConfig.assetsPath ? _path.default.isAbsolute(bundleConfig.assetsPath) ? bundleConfig.assetsPath : _path.default.join(_path.default.dirname(bundleConfig.bundlePath), bundleConfig.assetsPath) : _path.default.dirname(bundleConfig.bundlePath),
            manifestPath: bundleConfig.manifestPath
          } : false,
          providesModuleNodeModules: bundleConfig.providesModuleNodeModules || ['react-native'],
          hasteOptions: bundleConfig.hasteOptions || {},
          maxWorkers: bundleConfig.maxWorkers !== undefined ? Math.max(1, bundleConfig.maxWorkers) : env.maxWorkers !== undefined ? Math.max(1, env.maxWorkers) : Math.max(_isCi.default ? Math.min((0, _os.cpus)().length - 1, 7) : (0, _os.cpus)().length - 1, 1)
        }; // Make sure user supplied manifestPath if the bundle is DLL. Otherwise, we wouldn't
        // have any info what the bundle contains.

        if (normalizedBundleConfig.dll && normalizedBundleConfig.external && !normalizedBundleConfig.external.manifestPath) {
          throw new Error(`Missing 'manifestPath' for external DLL '${normalizedBundleConfig.name}'`);
        } // Make sure the target platform is supported. Do not run this check when target is set
        // to server, since the initial configuration loading is done with `platform` set
        // to "".


        if (!platforms.includes(normalizedBundleConfig.platform) && env.bundleTarget !== 'server') {
          throw new Error(`Platform "${normalizedBundleConfig.platform}" is not supported - only: ${platforms.map(platform => `"${platform}"`).join(', ')} are available.`);
        }

        normalizedBundleConfigs[normalizedBundleConfig.name] = normalizedBundleConfig;
        transforms[normalizedBundleConfig.name] = bundleConfig.transform;
      });
      const bundleIdsMap = Object.keys(normalizedBundleConfigs).reduce((acc, bundleName, index) => {
        return { ...acc,
          [bundleName]: index
        };
      }, {});
      Object.keys(normalizedBundleConfigs).forEach(bundleName => {
        const normalizedBundleConfig = normalizedBundleConfigs[bundleName];
        let webpackConfig = getDefaultConfig(runtime, env, normalizedBundleConfig.name, {
          server: normalizedServerConfig,
          platforms,
          templates: normalizedTemplatesConfig,
          bundles: {
            // Pass only it's own normalized bundle config
            [normalizedBundleConfig.name]: normalizedBundleConfig
          },
          webpackConfigs: {}
        });

        if (env.assetsDest) {
          webpackConfig.output.path = _path.default.isAbsolute(env.assetsDest) ? env.assetsDest : _path.default.join(normalizedBundleConfig.root, env.assetsDest);
        }

        if (env.sourcemapOutput) {
          webpackConfig.output.sourceMapFilename = _path.default.isAbsolute(env.sourcemapOutput) ? _path.default.relative(webpackConfig.output.path, env.sourcemapOutput) : _path.default.relative(webpackConfig.output.path, _path.default.join(normalizedBundleConfig.root, env.sourcemapOutput));
        } else {
          webpackConfig.output.sourceMapFilename = '[file].map';
        }

        webpackConfig.plugins = (webpackConfig.plugins || []).concat((0, _getSourceMapPlugin.default)(normalizedBundleConfig, normalizedServerConfig, webpackConfig.output.sourceMapFilename)).filter(Boolean);
        webpackConfig.plugins = (webpackConfig.plugins || []).concat(normalizedBundleConfig.type === 'basic-bundle' ? new _BasicBundleWebpackPlugin.default({
          preloadBundles: featuresConfig.multiBundle === 1 ? normalizedBundleConfig.dependsOn : []
        }) : new _RamBundleWebpackPlugin.default({
          minify: normalizedBundleConfig.minify,
          minifyOptions: normalizedBundleConfig.minifyOptions,
          sourceMap: Boolean(normalizedBundleConfig.sourceMap),
          indexRamBundle: normalizedBundleConfig.type === 'indexed-ram-bundle',
          singleBundleMode: env.bundleMode === 'single-bundle',
          preloadBundles: featuresConfig.multiBundle === 1 ? normalizedBundleConfig.dependsOn : [],
          maxWorkers: env.maxWorkers || normalizedBundleConfig.maxWorkers,
          bundleId: featuresConfig.multiBundle === 1 ? bundleName : bundleIdsMap[bundleName],
          bundleName
        }), new _webpack.default.DefinePlugin({
          'process.env.HAUL_BUNDLES': JSON.stringify(bundleIdsMap)
        }));
        webpackConfig.plugins.push(new _LooseModeWebpackPlugin.default(normalizedBundleConfig.looseMode));

        if (normalizedBundleConfig.dll && normalizedBundleConfig.entry.setupFiles.length > 0 && featuresConfig.multiBundle >= 2) {
          webpackConfig.plugins.push(new _InitCoreDllPlugin.default({
            setupFiles: normalizedBundleConfig.entry.setupFiles
          }));
        }

        if (env.bundleMode === 'single-bundle') {
          (0, _applySingleBundleTweaks.default)(env, normalizedTemplatesConfig, normalizedBundleConfig, webpackConfig);
        } else if (env.bundleMode === 'multi-bundle') {
          (0, _applyMultiBundleTweaks.default)(env, normalizedTemplatesConfig, normalizedBundleConfig, webpackConfig, normalizedBundleConfigs);
        }

        const transform = transforms[bundleName];

        if (transform) {
          webpackConfig = transform({
            bundleName: normalizedBundleConfig.name,
            config: webpackConfig,
            env,
            runtime
          }) || webpackConfig;
        }

        webpackConfigs[normalizedBundleConfig.name] = webpackConfig;
      });
      return {
        server: normalizedServerConfig,
        platforms,
        templates: normalizedTemplatesConfig,
        bundles: normalizedBundleConfigs,
        webpackConfigs
      };
    };
  };
}
//# sourceMappingURL=makeConfigFactory.js.map