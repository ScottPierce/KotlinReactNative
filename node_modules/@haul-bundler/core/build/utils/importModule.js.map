{"version":3,"sources":["../../src/utils/importModule.ts"],"names":["importModule","filename","options","resolve","parentModule","ignore","cache","runtime","exports","loadModule","module","nativeRequire","require","builtinModules","concat","Module","provided","moduleFilename","includes","moduleBody","fs","readFileSync","error","Error","code","paths","_resolveLookupPaths","reduce","acc","item","Array","isArray","path","dirname","id","currentResolve","createRequireFromPath","currentRequire","moduleId","test","JSON","parse","moduleFactory","vm","runInThisContext","wrap","shouldTranspile","some","ignorePattern","startsWith","transpilationResults","babel","transformSync","presets","targets","node","plugins","logger","loaded"],"mappings":"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","sourcesContent":["import fs from 'fs';\nimport path from 'path';\nimport vm from 'vm';\nimport Module from 'module';\nimport * as babel from '@babel/core';\nimport Runtime from '../runtime/Runtime';\n\ntype ModuleCache = { [id: string]: Module };\n\ntype Options = {\n  resolve: (moduleId: string) => string;\n  parentModule?: Module;\n  ignore?: Array<string | RegExp> | ((moduleId: string) => boolean);\n  cache?: ModuleCache;\n  runtime: Runtime;\n};\n\nexport default function importModule(filename: string, options: Options) {\n  const { resolve, parentModule, ignore = [], cache = {}, runtime } = options;\n\n  const exports = loadModule(filename, {\n    resolve,\n    parentModule: parentModule || module,\n    ignore,\n    cache,\n    runtime,\n  });\n\n  return {\n    exports,\n    cache,\n  };\n}\n\nconst nativeRequire = require;\nconst builtinModules = ['debug'].concat(Module.builtinModules);\n\nfunction loadModule(\n  filename: string,\n  provided: {\n    resolve: Options['resolve'];\n    parentModule: NonNullable<Options['parentModule']>;\n    ignore: NonNullable<Options['ignore']>;\n    cache: NonNullable<Options['cache']>;\n    runtime: Runtime;\n  }\n) {\n  // Resolve absolute module location using parent's resolver.\n  const moduleFilename = provided.resolve(filename);\n\n  // Use native require if requested module is a build-in one.\n  // Built-in modules are not kept in isolated cache, but in the native cache.\n  if (builtinModules.includes(moduleFilename)) {\n    return nativeRequire(moduleFilename);\n  }\n\n  // Use exports from cache is available.\n  if (provided.cache[moduleFilename]) {\n    return provided.cache[moduleFilename].exports;\n  }\n\n  let moduleBody: string;\n  try {\n    moduleBody = fs.readFileSync(moduleFilename, 'utf8');\n  } catch (error) {\n    throw new Error(\n      `Module '${filename}' resolved to '${moduleFilename}' not found: ${error.code}`\n    );\n  }\n\n  // Instantiating a new Module will setup some some properties, but won't\n  // load the module code by itself, so we can do it ourselves later.\n  const module = new Module(moduleFilename, provided.parentModule);\n  module.filename = moduleFilename;\n  // Resolve lookup paths (for example paths to node_modules for each parent directory).\n  module.paths = ((Module as unknown) as {\n    _resolveLookupPaths: (request: string, parent?: Module) => string[][];\n  })\n    ._resolveLookupPaths(module.filename, provided.parentModule)\n    .reduce(\n      (acc, item) =>\n        Array.isArray(item) ? acc.concat(...item) : acc.concat(item),\n      []\n    )\n    .concat(path.dirname(module.filename));\n  provided.cache[module.id] = module;\n\n  // Create resolver for this module.\n  const currentResolve = ((Module.createRequireFromPath(\n    module.filename\n  ) as unknown) as {\n    resolve: RequireResolve;\n  }).resolve;\n\n  // Create require function for this module.\n  const currentRequire = (moduleId: string) => {\n    return loadModule(moduleId, {\n      resolve: currentResolve,\n      parentModule: module,\n      ignore: provided.ignore,\n      cache: provided.cache,\n      runtime: provided.runtime,\n    });\n  };\n\n  // Set `resolve` and `cache` on `require` function.\n  currentRequire.resolve = currentResolve;\n  currentRequire.cache = provided.cache;\n\n  // Special case for JSON files.\n  if (/\\.json$/.test(module.filename)) {\n    module.exports = JSON.parse(moduleBody);\n  } else {\n    let moduleFactory: Function;\n    try {\n      // Try to create a module factory function. If it fails, there's a good cache that the\n      // module needs to be transpiled.\n      moduleFactory = vm.runInThisContext(Module.wrap('\\n' + moduleBody), {\n        filename: module.filename,\n      });\n    } catch (error) {\n      // Figure out if module should be transpiled.\n      let shouldTranspile = true;\n      if (typeof provided.ignore === 'function') {\n        shouldTranspile = !provided.ignore(module.filename);\n      } else {\n        shouldTranspile = !provided.ignore.some(ignorePattern => {\n          if (typeof ignorePattern === 'string') {\n            return module.filename.startsWith(ignorePattern);\n          }\n\n          return ignorePattern.test(module.filename);\n        });\n      }\n\n      // Throw original error if module ignored and thus should not be transpiled.\n      if (!shouldTranspile) {\n        throw error;\n      }\n\n      // If the parsing failed, transpile the code with babel and try again.\n      let transpilationResults: babel.BabelFileResult | null;\n      try {\n        // Use hardcoded plugins and preset, since we cannot use Babel config from project, due\n        // to different targets - project babel config might have commonjs transform disabled etc.\n        transpilationResults = babel.transformSync(moduleBody, {\n          filename: module.filename,\n          presets: [\n            [\n              require.resolve('@babel/preset-env'),\n              {\n                targets: {\n                  node: 'current',\n                },\n              },\n            ],\n            require.resolve('@babel/preset-typescript'),\n          ],\n          plugins: [\n            require.resolve('@babel/plugin-proposal-class-properties'),\n            require.resolve('@babel/plugin-transform-flow-strip-types'),\n          ],\n        });\n      } catch (error) {\n        // Transpilation failed. Babel sometimes might not print which file it was transpiling\n        // so, log it here and then throw error from Babel.\n        provided.runtime.logger.error(\n          `Failed to transpile module ${module.filename}:`\n        );\n        throw error;\n      }\n\n      if (transpilationResults?.code) {\n        // Try to evaluate the module factory again using transpiled code. If it fails, the\n        // error will propagate to up the stack - there's nothing we need to do.\n        moduleFactory = vm.runInThisContext(\n          Module.wrap('\\n' + transpilationResults.code),\n          {\n            filename: module.filename,\n          }\n        );\n      } else {\n        // Edge case if transpilation failed, but we don't know why.\n        throw new Error(\n          `Failed to transpile module ${module.filename} due to unknown reason`\n        );\n      }\n    }\n\n    // Evaluate the actual module's code.\n    moduleFactory(\n      module.exports,\n      currentRequire,\n      module,\n      module.filename,\n      path.dirname(module.filename)\n    );\n  }\n\n  module.loaded = true;\n  return module.exports;\n}\n"],"file":"importModule.js"}