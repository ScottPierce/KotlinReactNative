"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = importModule;

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _vm = _interopRequireDefault(require("vm"));

var _module = _interopRequireDefault(require("module"));

var babel = _interopRequireWildcard(require("@babel/core"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function importModule(filename, options) {
  const {
    resolve,
    parentModule,
    ignore = [],
    cache = {},
    runtime
  } = options;
  const exports = loadModule(filename, {
    resolve,
    parentModule: parentModule || module,
    ignore,
    cache,
    runtime
  });
  return {
    exports,
    cache
  };
}

const nativeRequire = require;
const builtinModules = ['debug'].concat(_module.default.builtinModules);

function loadModule(filename, provided) {
  // Resolve absolute module location using parent's resolver.
  const moduleFilename = provided.resolve(filename); // Use native require if requested module is a build-in one.
  // Built-in modules are not kept in isolated cache, but in the native cache.

  if (builtinModules.includes(moduleFilename)) {
    return nativeRequire(moduleFilename);
  } // Use exports from cache is available.


  if (provided.cache[moduleFilename]) {
    return provided.cache[moduleFilename].exports;
  }

  let moduleBody;

  try {
    moduleBody = _fs.default.readFileSync(moduleFilename, 'utf8');
  } catch (error) {
    throw new Error(`Module '${filename}' resolved to '${moduleFilename}' not found: ${error.code}`);
  } // Instantiating a new Module will setup some some properties, but won't
  // load the module code by itself, so we can do it ourselves later.


  const module = new _module.default(moduleFilename, provided.parentModule);
  module.filename = moduleFilename; // Resolve lookup paths (for example paths to node_modules for each parent directory).

  module.paths = _module.default._resolveLookupPaths(module.filename, provided.parentModule).reduce((acc, item) => Array.isArray(item) ? acc.concat(...item) : acc.concat(item), []).concat(_path.default.dirname(module.filename));
  provided.cache[module.id] = module; // Create resolver for this module.

  const currentResolve = _module.default.createRequireFromPath(module.filename).resolve; // Create require function for this module.


  const currentRequire = moduleId => {
    return loadModule(moduleId, {
      resolve: currentResolve,
      parentModule: module,
      ignore: provided.ignore,
      cache: provided.cache,
      runtime: provided.runtime
    });
  }; // Set `resolve` and `cache` on `require` function.


  currentRequire.resolve = currentResolve;
  currentRequire.cache = provided.cache; // Special case for JSON files.

  if (/\.json$/.test(module.filename)) {
    module.exports = JSON.parse(moduleBody);
  } else {
    let moduleFactory;

    try {
      // Try to create a module factory function. If it fails, there's a good cache that the
      // module needs to be transpiled.
      moduleFactory = _vm.default.runInThisContext(_module.default.wrap('\n' + moduleBody), {
        filename: module.filename
      });
    } catch (error) {
      var _transpilationResults;

      // Figure out if module should be transpiled.
      let shouldTranspile = true;

      if (typeof provided.ignore === 'function') {
        shouldTranspile = !provided.ignore(module.filename);
      } else {
        shouldTranspile = !provided.ignore.some(ignorePattern => {
          if (typeof ignorePattern === 'string') {
            return module.filename.startsWith(ignorePattern);
          }

          return ignorePattern.test(module.filename);
        });
      } // Throw original error if module ignored and thus should not be transpiled.


      if (!shouldTranspile) {
        throw error;
      } // If the parsing failed, transpile the code with babel and try again.


      let transpilationResults;

      try {
        // Use hardcoded plugins and preset, since we cannot use Babel config from project, due
        // to different targets - project babel config might have commonjs transform disabled etc.
        transpilationResults = babel.transformSync(moduleBody, {
          filename: module.filename,
          presets: [[require.resolve('@babel/preset-env'), {
            targets: {
              node: 'current'
            }
          }], require.resolve('@babel/preset-typescript')],
          plugins: [require.resolve('@babel/plugin-proposal-class-properties'), require.resolve('@babel/plugin-transform-flow-strip-types')]
        });
      } catch (error) {
        // Transpilation failed. Babel sometimes might not print which file it was transpiling
        // so, log it here and then throw error from Babel.
        provided.runtime.logger.error(`Failed to transpile module ${module.filename}:`);
        throw error;
      }

      if ((_transpilationResults = transpilationResults) === null || _transpilationResults === void 0 ? void 0 : _transpilationResults.code) {
        // Try to evaluate the module factory again using transpiled code. If it fails, the
        // error will propagate to up the stack - there's nothing we need to do.
        moduleFactory = _vm.default.runInThisContext(_module.default.wrap('\n' + transpilationResults.code), {
          filename: module.filename
        });
      } else {
        // Edge case if transpilation failed, but we don't know why.
        throw new Error(`Failed to transpile module ${module.filename} due to unknown reason`);
      }
    } // Evaluate the actual module's code.


    moduleFactory(module.exports, currentRequire, module, module.filename, _path.default.dirname(module.filename));
  }

  module.loaded = true;
  return module.exports;
}
//# sourceMappingURL=importModule.js.map