{"version":3,"sources":["../../src/compiler/Compiler.js"],"names":["EventEmitter","require","fs","Events","Fork","TaskQueue","module","exports","Compiler","constructor","options","logger","forks","tasks","on","REQUEST_BUNDLE","bundleOptions","platform","filename","callback","initFork","configOptions","isProcessing","once","BUILD_FINISHED","stats","errors","length","mimeType","file","taskId","add","send","REQUEST_FILE","Object","keys","awaitingCount","forEach","fork","init","message","emit","BUILD_FAILED","FILE_NOT_FOUND","pop","set","FILE_RECEIVED","filePath","readFileSync","LOG","level","BUILD_START","payload","BUILD_PROGRESS","terminate"],"mappings":"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","sourcesContent":["/**\n * Copyright 2017-present, Callstack.\n * All rights reserved.\n *\n * @flow\n */\n\nimport type { Platform } from '../types';\n\nconst EventEmitter = require('events');\nconst fs = require('fs');\n\nconst Events = require('./events');\nconst Fork = require('./Fork');\nconst TaskQueue = require('./TaskQueue');\n\n/**\n * Compiler provides a interface over forks and handles theirs creation.\n * The consumer doesn't have to worry about to which fork emit a event,\n * but just provide a platform. They it's up to Compiler to route the event\n * to correct fork.\n */\nmodule.exports = class Compiler extends EventEmitter {\n  static get Events() {\n    return Events;\n  }\n\n  forks: { [key: Platform]: Fork };\n  tasks: TaskQueue;\n\n  constructor(options: *, logger) {\n    super();\n    this.forks = {};\n    this.tasks = new TaskQueue();\n    this.logger = logger;\n\n    this.on(\n      Events.REQUEST_BUNDLE,\n      async ({ bundleOptions, platform, filename, callback }) => {\n        if (!this.forks[platform]) {\n          this.forks[platform] = await this.initFork({\n            platform,\n            options: {\n              ...options,\n              configOptions: { ...options.configOptions, ...bundleOptions },\n            },\n          });\n        }\n\n        if (!this.forks[platform]) return;\n\n        // If the fork is compiling the bundle, attach listener to emit `REQUEST_FILE` once\n        // the bundle is created, otherwise simply request the file. Callback will be then invoked in\n        // `FILE_RECEIVED` listener.\n        if (this.forks[platform].isProcessing) {\n          this.forks[platform].once(Events.BUILD_FINISHED, ({ stats }) => {\n            if (stats.errors.length) {\n              callback({\n                errors: stats.errors,\n                platform,\n                mimeType: null,\n                file: null,\n              });\n            } else {\n              const taskId = this.tasks.add({ callback });\n              this.forks[platform].send(Events.REQUEST_FILE, {\n                filename,\n                taskId,\n              });\n            }\n          });\n        } else {\n          const taskId = this.tasks.add({ callback });\n          this.forks[platform].send(Events.REQUEST_FILE, { filename, taskId });\n        }\n      }\n    );\n\n    this.on(Events.REQUEST_FILE, ({ filename, callback }) => {\n      // If there are no forks spawned, execute callback immediately\n      // with null.\n      if (!Object.keys(this.forks).length) {\n        callback({\n          errors: null,\n          platform: null,\n          file: null,\n          mimeType: null,\n        });\n      }\n\n      // Callback will be invoked on `FILE_RECEIVED` event or on `FILE_NOT_FOUND`.\n      const taskId = this.tasks.add({\n        callback,\n        awaitingCount: Object.keys(this.forks).length,\n      });\n      // We cannot know in which fork the file is stored, so we send event to all\n      // of them and keep count of how many of them responded with `FILE_NOT_FOUND`.\n      Object.keys(this.forks).forEach(platform => {\n        this.forks[platform].send(Events.REQUEST_FILE, { filename, taskId });\n      });\n    });\n  }\n\n  /**\n   * Create fork process and attach necessary event listeners.\n   */\n  async initFork({ platform, options }: { platform: Platform, options: * }) {\n    let fork;\n    try {\n      fork = new Fork({ platform, options });\n      await fork.init();\n    } catch (message) {\n      this.emit(Events.BUILD_FAILED, { platform, message });\n      return null;\n    }\n\n    fork.on(Events.FILE_NOT_FOUND, ({ taskId }) => {\n      const { callback, awaitingCount } = this.tasks.pop(taskId);\n\n      // If the value is more than 1, it means that we are still awaiting\n      // responses, so we put the task back with the same ID and decremented count.\n      if (awaitingCount > 1) {\n        this.tasks.set(taskId, { callback, awaitingCount: awaitingCount - 1 });\n      } else if (callback) {\n        callback({\n          errors: null,\n          platform,\n          file: null,\n          mimeType: null,\n        });\n      }\n    });\n\n    fork.on(Events.FILE_RECEIVED, ({ filePath, taskId, mimeType }) => {\n      const { callback, awaitingCount } = this.tasks.pop(taskId);\n\n      // If the value is more than 1, it means that we are still awaiting\n      // responses from other forks, so we put the task back with the same ID and decremented count and null callback.\n      if (awaitingCount > 1) {\n        this.tasks.set(taskId, {\n          callback: null,\n          awaitingCount: awaitingCount - 1,\n        });\n      }\n      if (callback) {\n        callback({\n          errors: null,\n          platform,\n          file: fs.readFileSync(filePath),\n          mimeType,\n        });\n      }\n    });\n\n    fork.on(Events.LOG, ({ message, level }) => {\n      this.logger[level] && this.logger[level](message);\n\n      this.emit(Events.BUILD_START, { platform, message });\n    });\n\n    fork.on(Events.BUILD_START, payload => {\n      this.emit(Events.BUILD_START, { platform, ...payload });\n    });\n\n    fork.on(Events.BUILD_FINISHED, payload => {\n      this.emit(Events.BUILD_FINISHED, {\n        platform,\n        ...payload,\n        errors: payload.stats.errors,\n      });\n    });\n\n    fork.on(Events.BUILD_PROGRESS, payload => {\n      this.emit(Events.BUILD_PROGRESS, { platform, ...payload });\n    });\n\n    fork.on(Events.BUILD_FAILED, payload => {\n      this.emit(Events.BUILD_FAILED, { platform, ...payload });\n    });\n\n    return fork;\n  }\n\n  terminate() {\n    Object.keys(this.forks).forEach(platform =>\n      this.forks[platform].terminate()\n    );\n  }\n};\n"],"file":"Compiler.js"}