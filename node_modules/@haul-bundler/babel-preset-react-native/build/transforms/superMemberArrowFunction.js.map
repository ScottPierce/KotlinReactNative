{"version":3,"sources":["../../src/transforms/superMemberArrowFunction.ts"],"names":["template","superMemberArrowFunction","visitor","Program","programPath","traverse","Super","path","parentFunctionPath","getFunctionParent","isArrowFunctionExpression","parentPath","isClassProperty","parentClass","findParent","p","isClass","node","superClass","babel","types","isIdentifier","replaceWith","SUPER","METHOD","parent","property","ARGS","arguments"],"mappings":";;;;;;;AAAA;;AACA;;;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BA,MAAMA,QAAQ,GAAG,uBAAe,yCAAf,CAAjB;;AAEe,SAASC,wBAAT,GAAoC;AACjD,SAAO;AACLC,IAAAA,OAAO,EAAE;AACPC,MAAAA,OAAO,CAACC,WAAD,EAAmD;AACxDA,QAAAA,WAAW,CAACC,QAAZ,CAAqB;AACnBC,UAAAA,KAAK,CAACC,IAAD,EAAO;AACV,gBAAIC,kBAAkB,GAAGD,IAAI,CAACE,iBAAL,EAAzB,CADU,CAGV;;AACA,gBACED,kBAAkB,CAACE,yBAAnB,MACAF,kBAAkB,CAACG,UAAnB,CAA8BC,eAA9B,EAFF,EAGE;AACA;AACA,kBAAIC,WAAW,GAAGN,IAAI,CAACO,UAAL,CAAgBC,CAAC,IACjCA,CAAC,CAACC,OAAF,EADgB,CAAlB;;AAIA,kBACE,CAAAH,WAAW,SAAX,IAAAA,WAAW,WAAX,YAAAA,WAAW,CAAEI,IAAb,CAAkBC,UAAlB,KACAC,KAAK,CAACC,KAAN,CAAYC,YAAZ,CAAyBR,WAAW,CAACI,IAAZ,CAAiBC,UAA1C,CAFF,EAGE;AACAX,gBAAAA,IAAI,CAACI,UAAL,CAAgBA,UAAhB,CAA2BW,WAA3B,CACEtB,QAAQ,CAAC;AACPuB,kBAAAA,KAAK,EAAEV,WAAW,CAACI,IAAZ,CAAiBC,UADjB;AAEPM,kBAAAA,MAAM,EAAGjB,IAAI,CAACkB,MAAN,CACLC,QAHI;AAIPC,kBAAAA,IAAI,EAAGpB,IAAI,CAACI,UAAL,CAAgBc,MAAjB,CACHG;AALI,iBAAD,CADV;AASD;AACF;AACF;;AA7BkB,SAArB;AA+BD;;AAjCM;AADJ,GAAP;AAqCD","sourcesContent":["import createTemplate from '@babel/template';\nimport * as babel from '@babel/core';\n\n/**\n * With Webpack and babel-loader the following code:\n * ```js\n * class Derived extends Super {\n *   derivedFn1 = async () => {\n *     await super.superFn1();\n *   }\n *\n *   derivedFn2 = () => {\n *     super.superFn2();\n *   }\n * }\n * ```\n * will fail with an exception: `super` cannot be used outside of a class method.\n * However this is a valid syntax, which successfully run for example on V8 or Chrome,\n * so we need to transform `super` to use `Super.prototype`:\n * ```js\n * class Derived extends Super {\n *   derivedFn1 = async () => {\n *     await Super.prototype.superFn1.call(this);\n *   }\n *\n *   derivedFn2 = () => {\n *     Super.prototype.superFn2.call(this);\n *   }\n * }\n * ```\n */\n\nconst template = createTemplate('SUPER.prototype.METHOD.call(this, ARGS)');\n\nexport default function superMemberArrowFunction() {\n  return {\n    visitor: {\n      Program(programPath: babel.NodePath<babel.types.Program>) {\n        programPath.traverse({\n          Super(path) {\n            let parentFunctionPath = path.getFunctionParent();\n\n            // Check if parent function is an arrow function as a class property.\n            if (\n              parentFunctionPath.isArrowFunctionExpression() &&\n              parentFunctionPath.parentPath.isClassProperty()\n            ) {\n              // Find the parent class, and make sure it's extending from an identifier\n              let parentClass = path.findParent(p =>\n                p.isClass()\n              ) as babel.NodePath<babel.types.Class>;\n\n              if (\n                parentClass?.node.superClass &&\n                babel.types.isIdentifier(parentClass.node.superClass)\n              ) {\n                path.parentPath.parentPath.replaceWith(\n                  template({\n                    SUPER: parentClass.node.superClass,\n                    METHOD: (path.parent as babel.types.MemberExpression)\n                      .property,\n                    ARGS: (path.parentPath.parent as babel.types.CallExpression)\n                      .arguments,\n                  }) as any\n                );\n              }\n            }\n          },\n        });\n      },\n    },\n  };\n}\n"],"file":"superMemberArrowFunction.js"}