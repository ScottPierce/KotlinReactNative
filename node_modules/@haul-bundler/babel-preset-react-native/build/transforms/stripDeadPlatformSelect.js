"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = stripDeadPlatformSelect;

var babel = _interopRequireWildcard(require("@babel/core"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function stripDeadPlatformSelect() {
  return {
    visitor: {
      CallExpression(path, state) {
        if (babel.types.isMemberExpression(path.node.callee) && babel.types.isIdentifier(path.node.callee.object) && babel.types.isIdentifier(path.node.callee.property) && path.node.callee.object.name === 'Platform' && path.node.callee.property.name === 'select' && babel.types.isObjectExpression(path.node.arguments[0])) {
          const platformsSpecs = path.node.arguments[0];
          let canStripPlatformSelect = true;
          let targetCase;
          let defaultCase;
          const additionalProperties = [];
          platformsSpecs.properties.forEach(property => {
            if (babel.types.isObjectProperty(property) && babel.types.isIdentifier(property.key)) {
              if (property.key.name === 'default') {
                defaultCase = property;
              } else if (property.key.name === state.opts.platform) {
                targetCase = property;
              }
            } else {
              canStripPlatformSelect = false;
              additionalProperties.push(property);
            }
          }); // If we got exact mach, we can strip the rest

          if (targetCase) {
            canStripPlatformSelect = true;
          }

          if (!targetCase && !defaultCase && canStripPlatformSelect) {
            path.replaceWithSourceString('undefined');
          } else if (canStripPlatformSelect && (targetCase || defaultCase)) {
            path.replaceWith((targetCase || defaultCase).value);
          } else {
            platformsSpecs.properties = [targetCase || defaultCase, ...additionalProperties].filter(Boolean);
          }
        }
      }

    }
  };
}
//# sourceMappingURL=stripDeadPlatformSelect.js.map